---
description: When editing or working with the runtime package
globs: 
alwaysApply: false
---
# Runtime Client GraphQL Package

## Overview

The `@copilotkit/runtime-client-gql` package provides a GraphQL client for communicating with CopilotKit runtime servers. It handles message streaming, agent state management, and provides type-safe GraphQL operations for AI assistant interactions.

## Core Components

### CopilotRuntimeClient

The main client class for GraphQL communication with CopilotKit runtime:

```typescript
import { CopilotRuntimeClient } from "@copilotkit/runtime-client-gql";

const client = new CopilotRuntimeClient({
  url: "http://localhost:8000/graphql",
  publicApiKey: "your-api-key", // Optional for cloud deployments
  headers: { "Custom-Header": "value" },
  credentials: "include", // For cookies/auth
  handleGQLErrors: (error) => console.error("GraphQL Error:", error),
  handleGQLWarning: (warning) => console.warn("Warning:", warning)
});
```

### Key Features

- **Version Mismatch Detection**: Automatically detects version mismatches between client and runtime
- **Error Handling**: Structured error handling with custom error handlers
- **Streaming Support**: Built-in support for GraphQL streaming responses
- **Type Safety**: Full TypeScript support with generated GraphQL types
- **Abort Signal Support**: Request cancellation with AbortController

## Message Types

### Base Message Classes

```typescript
import { 
  Message, 
  TextMessage, 
  ActionExecutionMessage, 
  ResultMessage, 
  AgentStateMessage,
  ImageMessage,
  Role 
} from "@copilotkit/runtime-client-gql";

// Text messages for conversation
const textMessage = new TextMessage({
  id: "msg-123",
  content: "Hello, how can I help?",
  role: Role.Assistant,
  parentMessageId: "parent-msg"
});

// Action execution messages
const actionMessage = new ActionExecutionMessage({
  id: "action-123",
  name: "updateUser",
  arguments: { field: "name", value: "John" },
  parentMessageId: "msg-123"
});

// Result messages for action responses
const resultMessage = new ResultMessage({
  id: "result-123",
  actionExecutionId: "action-123",
  actionName: "updateUser",
  result: "User updated successfully"
});

// Agent state messages for multi-agent workflows
const agentStateMessage = new AgentStateMessage({
  id: "agent-123",
  agentName: "research_agent",
  state: { data: "research results" },
  running: true,
  threadId: "thread-123",
  role: Role.Assistant
});
```

### Message Type Guards

```typescript
const message = new TextMessage({ content: "Hello" });

if (message.isTextMessage()) {
  console.log(message.content); // TypeScript knows this is a TextMessage
}

if (message.isActionExecutionMessage()) {
  console.log(message.name); // TypeScript knows this is an ActionExecutionMessage
}
```

## GraphQL Operations

### Generate Copilot Response

```typescript
const response = client.generateCopilotResponse({
  data: {
    messages: [
      new TextMessage({
        content: "What's the weather like?",
        role: Role.User
      })
    ],
    threadId: "thread-123",
    agentName: "weather_agent"
  },
  properties: {
    temperature: 0.7,
    maxTokens: 1000
  },
  signal: abortController.signal // Optional abort signal
});

// Handle streaming response
response.subscribe(({ data, error, hasNext }) => {
  if (error) {
    console.error("Error:", error);
    return;
  }
  
  if (data) {
    console.log("Response:", data);
  }
  
  if (!hasNext) {
    console.log("Stream complete");
  }
});
```

### Available Agents Query

```typescript
const agentsQuery = client.availableAgents();

agentsQuery.subscribe(({ data, error }) => {
  if (error) {
    console.error("Error fetching agents:", error);
    return;
  }
  
  if (data) {
    console.log("Available agents:", data.availableAgents);
  }
});
```

### Load Agent State

```typescript
const stateQuery = client.loadAgentState({
  threadId: "thread-123",
  agentName: "research_agent"
});

stateQuery.subscribe(({ data, error }) => {
  if (error) {
    console.error("Error loading state:", error);
    return;
  }
  
  if (data) {
    console.log("Agent state:", data.loadAgentState);
  }
});
```

## Message Conversion

### AGUI to GraphQL Conversion

Convert AGUI (Agent GUI) messages to GraphQL format:

```typescript
import { aguiToGQL } from "@copilotkit/runtime-client-gql";

const aguiMessages = [
  {
    id: "msg-1",
    role: "user",
    content: "Hello"
  },
  {
    id: "msg-2", 
    role: "assistant",
    content: "Hi there!",
    toolCalls: [
      {
        id: "tool-1",
        type: "function",
        function: {
          name: "getWeather",
          arguments: '{"city": "New York"}'
        }
      }
    ]
  }
];

const gqlMessages = aguiToGQL(aguiMessages);
```

### GraphQL to AGUI Conversion

Convert GraphQL messages back to AGUI format:

```typescript
import { gqlToAGUI } from "@copilotkit/runtime-client-gql";

const gqlMessages = [
  new TextMessage({
    id: "msg-1",
    content: "Hello",
    role: Role.User
  }),
  new ActionExecutionMessage({
    id: "tool-1",
    name: "getWeather",
    arguments: { city: "New York" },
    parentMessageId: "msg-1"
  })
];

const aguiMessages = gqlToAGUI(gqlMessages);
```

## Streaming Support

### ReadableStream Integration

```typescript
const response = client.generateCopilotResponse({
  data: { messages: [userMessage] }
});

// Convert to ReadableStream for modern streaming APIs
const stream = client.asStream(response);

// Use with fetch-like APIs
const reader = stream.getReader();
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  console.log("Stream chunk:", value);
}
```

### React Integration with Streaming

```typescript
import { useEffect, useState } from "react";
import { CopilotRuntimeClient } from "@copilotkit/runtime-client-gql";

function ChatComponent() {
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  
  const client = new CopilotRuntimeClient({
    url: "/api/graphql"
  });

  const sendMessage = async (content: string) => {
    setIsLoading(true);
    
    const response = client.generateCopilotResponse({
      data: {
        messages: [
          new TextMessage({
            content,
            role: Role.User
          })
        ]
      }
    });

    response.subscribe(({ data, error, hasNext }) => {
      if (error) {
        console.error("Error:", error);
        setIsLoading(false);
        return;
      }
      
      if (data) {
        setMessages(prev => [...prev, data]);
      }
      
      if (!hasNext) {
        setIsLoading(false);
      }
    });
  };

  return (
    <div>
      {/* Chat UI */}
    </div>
  );
}
```

## Error Handling

### Custom Error Handlers

```typescript
const client = new CopilotRuntimeClient({
  url: "/api/graphql",
  handleGQLErrors: (error) => {
    // Handle GraphQL errors
    if (error.graphQLErrors) {
      error.graphQLErrors.forEach(gqlError => {
        console.error("GraphQL Error:", gqlError.message);
      });
    }
    
    // Handle network errors
    if (error.networkError) {
      console.error("Network Error:", error.networkError);
    }
  },
  handleGQLWarning: (warning) => {
    // Handle warnings (e.g., version mismatches)
    console.warn("Warning:", warning);
  }
});
```

### Error Types

```typescript
import { 
  CopilotKitError,
  CopilotKitLowLevelError,
  CopilotKitVersionMismatchError,
  ResolvedCopilotKitError
} from "@copilotkit/runtime-client-gql";

// Handle specific error types
try {
  const response = client.generateCopilotResponse({ data });
} catch (error) {
  if (error instanceof CopilotKitVersionMismatchError) {
    console.error("Version mismatch:", error.message);
  } else if (error instanceof ResolvedCopilotKitError) {
    console.error("Server error:", error.status);
  } else if (error instanceof CopilotKitLowLevelError) {
    console.error("Network error:", error.error);
  }
}
```

## Advanced Patterns

### Request Cancellation

```typescript
const abortController = new AbortController();

const response = client.generateCopilotResponse({
  data: { messages: [userMessage] },
  signal: abortController.signal
});

// Cancel request after 5 seconds
setTimeout(() => {
  abortController.abort();
}, 5000);
```

### Batch Operations

```typescript
// Send multiple messages in sequence
const sendBatch = async (messages: string[]) => {
  for (const content of messages) {
    const response = client.generateCopilotResponse({
      data: {
        messages: [
          new TextMessage({
            content,
            role: Role.User
          })
        ]
      }
    });
    
    await new Promise((resolve) => {
      response.subscribe(({ hasNext }) => {
        if (!hasNext) resolve(undefined);
      });
    });
  }
};
```

### Custom Headers and Authentication

```typescript
const client = new CopilotRuntimeClient({
  url: "/api/graphql",
  headers: {
    "Authorization": `Bearer ${token}`,
    "X-Custom-Header": "value"
  },
  credentials: "include", // Include cookies
  publicApiKey: process.env.COPILOTKIT_PUBLIC_API_KEY
});
```

## Integration with React Core

```typescript
import { useCopilotChat, CopilotKit } from "@copilotkit/react-core";
import { CopilotRuntimeClient } from "@copilotkit/runtime-client-gql";

function ChatWithCustomClient() {
  const { messages, appendMessage, isLoading } = useCopilotChat({
    id: "custom-chat",
    headers: {
      "X-Custom-Header": "value"
    },
    initialMessages: [],
    makeSystemMessage: (message) => message
  });

  return (
    <div>
      {messages.map(message => (
        <div key={message.id}>
          {message.content}
        </div>
      ))}
    </div>
  );
}

// Provide custom client at the provider level
function App() {
  const client = new CopilotRuntimeClient({
    url: "/api/graphql",
    headers: {
      "Authorization": `Bearer ${token}`,
      "X-Custom-Header": "value"
    }
  });

  return (
    <CopilotKit 
      publicApiKey={process.env.COPILOTKIT_PUBLIC_API_KEY}
      client={client}
    >
      <ChatWithCustomClient />
    </CopilotKit>
  );
}
```

## Best Practices

1. **Error Handling**: Always implement proper error handlers for production
2. **Streaming**: Use streaming for real-time responses and better UX
3. **Type Safety**: Leverage TypeScript for compile-time error checking
4. **Version Management**: Keep client and runtime versions in sync
5. **Request Cancellation**: Implement abort signals for long-running requests
6. **Message Conversion**: Use conversion utilities for AGUI compatibility
7. **State Management**: Properly handle agent state for multi-agent workflows

## Dependencies

- `@urql/core`: GraphQL client library
- `@copilotkit/shared`: Shared utilities and types
- `graphql`: GraphQL runtime
- `urql`: React bindings for URQL

## Development

```bash
# Build the package
pnpm build

# Generate GraphQL types
pnpm graphql-codegen

# Run tests
pnpm test

# Watch mode for development
pnpm dev
```
