---
description: When editing or working with the shared package
globs: 
alwaysApply: false
---
# Shared and SDK Packages Guide

## Overview

The shared and SDK packages provide utility functions, types, and integrations for CopilotKit applications. They offer common functionality used across the ecosystem and SDK integrations for popular AI frameworks.

## @copilotkit/shared

The shared utilities package that provides common types, functions, and constants used across all CopilotKit packages.

### Core Exports

#### Types and Interfaces

```typescript
import {
  Parameter,
  FrontendAction,
  CopilotApiConfig,
  CopilotCloudConfig,
  FunctionCallHandler,
  CoAgentStateRenderHandler,
  DocumentPointer,
  TreeNodeId,
  Tree,
  MCPServerConfig
} from "@copilotkit/shared";

// Parameter type for action definitions
interface Parameter {
  name: string;
  type: "string" | "number" | "boolean" | "object" | "array";
  description?: string;
  required?: boolean;
  enum?: string[];
  attributes?: Parameter[];
}

// Frontend action interface
interface FrontendAction<T extends Parameter[] = []> {
  name: string;
  description?: string;
  parameters?: T;
  handler?: (args: ParameterArgs<T>) => Promise<any>;
  render?: (props: ActionRenderProps<T>) => React.ReactElement | string;
  renderAndWaitForResponse?: (props: ActionRenderPropsWait<T>) => React.ReactElement;
  disabled?: boolean;
  available?: "frontend" | "backend" | "both";
  pairedAction?: string;
}

// Copilot API configuration
interface CopilotApiConfig {
  chatApiEndpoint: string;
  publicApiKey?: string;
  headers?: Record<string, string>;
  credentials?: RequestCredentials;
  cloud?: CopilotCloudConfig;
  properties?: Record<string, any>;
  mcpServers?: MCPServerConfig[];
}
```

#### Utility Functions

```typescript
import {
  randomId,
  randomUUID,
  dataToUUID,
  parseJson,
  untruncateJson,
  validateParameter,
  validateAction,
  createParameterSchema,
  convertToJSON,
  convertFromJSON
} from "@copilotkit/shared";

// Generate random IDs
const id = randomId(); // Short random ID
const uuid = randomUUID(); // Full UUID

// Create deterministic UUID from data
const dataId = dataToUUID(JSON.stringify({ name: "test", value: 123 }), "prefix");

// JSON parsing with error handling
const parsed = parseJson('{"key": "value"}', { key: "default" });

// Handle truncated JSON
const untruncated = untruncateJson('{"key": "value", "nested": {');

// Parameter validation
const isValid = validateParameter({
  name: "test",
  type: "string",
  required: true
});

// Action validation
const actionValid = validateAction({
  name: "testAction",
  description: "Test action",
  parameters: [
    { name: "param", type: "string", required: true }
  ],
  handler: async ({ param }) => param
});

// Create JSON schema from parameters
const schema = createParameterSchema([
  { name: "name", type: "string", required: true },
  { name: "age", type: "number", required: false }
]);
```

#### Constants

```typescript
import {
  COPILOT_CLOUD_CHAT_URL,
  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,
  DEFAULT_SYSTEM_MESSAGE,
  DEFAULT_CHAT_INSTRUCTIONS,
  MESSAGE_TYPES,
  ROLE_TYPES,
  STATUS_CODES
} from "@copilotkit/shared";

// Default URLs and headers
const cloudUrl = COPILOT_CLOUD_CHAT_URL; // "https://api.copilotkit.ai/chat"
const apiKeyHeader = COPILOT_CLOUD_PUBLIC_API_KEY_HEADER; // "x-copilotkit-public-api-key"

// Default messages
const systemMessage = DEFAULT_SYSTEM_MESSAGE;
const chatInstructions = DEFAULT_CHAT_INSTRUCTIONS;

// Message and role types
const messageTypes = MESSAGE_TYPES; // ["text", "image", "action", "result", "agent_state"]
const roleTypes = ROLE_TYPES; // ["user", "assistant", "system"]
const statusCodes = STATUS_CODES; // ["pending", "executing", "completed", "failed"]
```

#### Error Classes

```typescript
import {
  CopilotKitError,
  ConfigurationError,
  MissingPublicApiKeyError,
  ValidationError,
  RuntimeError
} from "@copilotkit/shared";

// Base error class
class CopilotKitError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = "CopilotKitError";
  }
}

// Specific error types
throw new ConfigurationError("Invalid configuration");
throw new MissingPublicApiKeyError("Public API key is required");
throw new ValidationError("Invalid parameter");
throw new RuntimeError("Runtime error occurred");
```

#### Tree and Category Management

```typescript
import {
  createTree,
  addToTree,
  removeFromTree,
  getTreeString,
  createFlatCategoryStore,
  addToCategoryStore,
  removeFromCategoryStore,
  getCategoryItems
} from "@copilotkit/shared";

// Tree management for hierarchical context
const tree = createTree();
const nodeId = addToTree(tree, "Context item", "parent-id");
removeFromTree(tree, nodeId);
const contextString = getTreeString(tree, ["category1", "category2"]);

// Flat category store for document context
const categoryStore = createFlatCategoryStore();
addToCategoryStore(categoryStore, {
  id: "doc1",
  content: "Document content",
  categories: ["docs", "reference"]
});
const documents = getCategoryItems(categoryStore, ["docs"]);
```

## @copilotkit/sdk-js

The JavaScript SDK package that provides integrations with popular AI frameworks like LangChain and LangGraph.

### Core Exports

#### LangChain Integration

```typescript
import {
  createLangChainTool,
  createLangChainAgent,
  createLangChainMemory,
  createLangChainChain,
  LangChainToolConfig,
  LangChainAgentConfig,
  LangChainMemoryConfig
} from "@copilotkit/sdk-js/langchain";

// Create LangChain tools
const tool = createLangChainTool({
  name: "search",
  description: "Search for information",
  schema: {
    type: "object",
    properties: {
      query: { type: "string", description: "Search query" }
    },
    required: ["query"]
  },
  handler: async ({ query }) => {
    // Tool implementation
    return await searchWeb(query);
  }
});

// Create LangChain agent
const agent = createLangChainAgent({
  model: "openai",
  tools: [tool],
  memory: {
    type: "conversation",
    maxTokens: 2000
  },
  systemMessage: "You are a helpful assistant"
});

// Create LangChain memory
const memory = createLangChainMemory({
  type: "conversation",
  maxTokens: 2000,
  returnMessages: true
});

// Create LangChain chain
const chain = createLangChainChain({
  type: "conversation",
  model: "openai",
  memory: memory,
  prompt: "You are a helpful assistant"
});
```

#### LangGraph Integration

```typescript
import {
  createLangGraphNode,
  createLangGraphEdge,
  createLangGraphGraph,
  createLangGraphState,
  LangGraphNodeConfig,
  LangGraphEdgeConfig,
  LangGraphGraphConfig,
  LangGraphStateConfig
} from "@copilotkit/sdk-js/langgraph";

// Create LangGraph nodes
const startNode = createLangGraphNode({
  name: "start",
  type: "start",
  handler: async (state) => {
    return { ...state, step: "processing" };
  }
});

const processNode = createLangGraphNode({
  name: "process",
  type: "tool",
  tool: "process_input",
  handler: async (state) => {
    const result = await processInput(state.input);
    return { ...state, result, step: "complete" };
  }
});

const endNode = createLangGraphNode({
  name: "end",
  type: "end",
  handler: async (state) => {
    return { ...state, completed: true };
  }
});

// Create LangGraph edges
const edges = [
  createLangGraphEdge({ from: "start", to: "process" }),
  createLangGraphEdge({ from: "process", to: "end" })
];

// Create LangGraph graph
const graph = createLangGraphGraph({
  nodes: [startNode, processNode, endNode],
  edges: edges,
  state: {
    input: "",
    result: null,
    step: "start",
    completed: false
  }
});

// Create LangGraph state
const state = createLangGraphState({
  input: "Hello, world!",
  result: null,
  step: "start",
  completed: false
});
```

#### Tool Creation Utilities

```typescript
import {
  createTool,
  createAsyncTool,
  createStreamingTool,
  createToolWithValidation,
  ToolConfig,
  AsyncToolConfig,
  StreamingToolConfig
} from "@copilotkit/sdk-js";

// Create basic tool
const basicTool = createTool({
  name: "basic_tool",
  description: "A basic tool",
  parameters: [
    { name: "input", type: "string", required: true }
  ],
  handler: ({ input }) => {
    return `Processed: ${input}`;
  }
});

// Create async tool
const asyncTool = createAsyncTool({
  name: "async_tool",
  description: "An async tool",
  parameters: [
    { name: "query", type: "string", required: true }
  ],
  handler: async ({ query }) => {
    const result = await fetch(`/api/search?q=${query}`);
    return await result.json();
  }
});

// Create streaming tool
const streamingTool = createStreamingTool({
  name: "streaming_tool",
  description: "A streaming tool",
  parameters: [
    { name: "prompt", type: "string", required: true }
  ],
  handler: async function* ({ prompt }) {
    const stream = await generateStream(prompt);
    for await (const chunk of stream) {
      yield chunk;
    }
  }
});

// Create tool with validation
const validatedTool = createToolWithValidation({
  name: "validated_tool",
  description: "A tool with validation",
  parameters: [
    { name: "email", type: "string", required: true }
  ],
  validate: ({ email }) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error("Invalid email format");
    }
  },
  handler: ({ email }) => {
    return `Email validated: ${email}`;
  }
});
```

#### Agent Creation Utilities

```typescript
import {
  createAgent,
  createMultiAgent,
  createAgentWithMemory,
  createAgentWithTools,
  AgentConfig,
  MultiAgentConfig,
  AgentWithMemoryConfig,
  AgentWithToolsConfig
} from "@copilotkit/sdk-js";

// Create basic agent
const agent = createAgent({
  name: "basic_agent",
  model: "openai",
  systemMessage: "You are a helpful assistant",
  temperature: 0.7
});

// Create multi-agent
const multiAgent = createMultiAgent({
  name: "multi_agent",
  agents: [
    {
      name: "researcher",
      role: "Research specialist",
      goal: "Find relevant information",
      tools: ["search", "read"]
    },
    {
      name: "writer",
      role: "Content writer",
      goal: "Create compelling content",
      tools: ["write", "edit"]
    }
  ],
  tasks: [
    {
      description: "Research the topic",
      agent: "researcher"
    },
    {
      description: "Write the content",
      agent: "writer"
    }
  ]
});

// Create agent with memory
const agentWithMemory = createAgentWithMemory({
  name: "memory_agent",
  model: "openai",
  memory: {
    type: "conversation",
    maxTokens: 2000
  },
  systemMessage: "You are a helpful assistant with memory"
});

// Create agent with tools
const agentWithTools = createAgentWithTools({
  name: "tool_agent",
  model: "openai",
  tools: [
    {
      name: "search",
      description: "Search for information",
      parameters: [
        { name: "query", type: "string", required: true }
      ],
      handler: async ({ query }) => {
        return await searchWeb(query);
      }
    }
  ],
  systemMessage: "You are a helpful assistant with tools"
});
```

#### Memory Management

```typescript
import {
  createMemory,
  createConversationMemory,
  createSummaryMemory,
  createBufferMemory,
  MemoryConfig,
  ConversationMemoryConfig,
  SummaryMemoryConfig,
  BufferMemoryConfig
} from "@copilotkit/sdk-js";

// Create conversation memory
const conversationMemory = createConversationMemory({
  maxTokens: 2000,
  returnMessages: true,
  inputKey: "input",
  outputKey: "output"
});

// Create summary memory
const summaryMemory = createSummaryMemory({
  maxTokens: 1000,
  summaryPrompt: "Summarize the conversation so far",
  returnMessages: true
});

// Create buffer memory
const bufferMemory = createBufferMemory({
  maxTokens: 1000,
  returnMessages: true
});
```

#### Chain Creation

```typescript
import {
  createChain,
  createConversationChain,
  createLLMChain,
  createSequentialChain,
  ChainConfig,
  ConversationChainConfig,
  LLMChainConfig,
  SequentialChainConfig
} from "@copilotkit/sdk-js";

// Create conversation chain
const conversationChain = createConversationChain({
  model: "openai",
  memory: conversationMemory,
  prompt: "You are a helpful assistant"
});

// Create LLM chain
const llmChain = createLLMChain({
  model: "openai",
  prompt: "Translate the following text to French: {text}"
});

// Create sequential chain
const sequentialChain = createSequentialChain({
  chains: [
    {
      name: "translate",
      chain: llmChain,
      inputKey: "text"
    },
    {
      name: "summarize",
      chain: createLLMChain({
        model: "openai",
        prompt: "Summarize: {translate}"
      }),
      inputKey: "translate"
    }
  ]
});
```

#### Integration Examples

```typescript
// Complete LangChain integration
import { createLangChainAgent } from "@copilotkit/sdk-js/langchain";

const langChainAgent = createLangChainAgent({
  model: "openai",
  tools: [
    {
      name: "search",
      description: "Search for information",
      schema: {
        type: "object",
        properties: {
          query: { type: "string" }
        },
        required: ["query"]
      },
      handler: async ({ query }) => {
        return await searchWeb(query);
      }
    }
  ],
  memory: {
    type: "conversation",
    maxTokens: 2000
  },
  systemMessage: "You are a helpful assistant with search capabilities"
});

// Complete LangGraph integration
import { createLangGraphGraph } from "@copilotkit/sdk-js/langgraph";

const langGraphWorkflow = createLangGraphGraph({
  nodes: [
    {
      name: "start",
      type: "start",
      handler: async (state) => ({ ...state, step: "processing" })
    },
    {
      name: "search",
      type: "tool",
      tool: "search",
      handler: async (state) => {
        const results = await searchWeb(state.query);
        return { ...state, results, step: "complete" };
      }
    },
    {
      name: "end",
      type: "end",
      handler: async (state) => ({ ...state, completed: true })
    }
  ],
  edges: [
    { from: "start", to: "search" },
    { from: "search", to: "end" }
  ],
  state: {
    query: "",
    results: null,
    step: "start",
    completed: false
  }
});
```

## Best Practices

1. **Type Safety**: Always use TypeScript interfaces for configuration
2. **Error Handling**: Implement proper error handling in tool handlers
3. **Validation**: Use validation functions for input parameters
4. **Memory Management**: Configure appropriate memory limits
5. **Tool Design**: Create focused, well-described tools
6. **Agent Configuration**: Use appropriate models and settings
7. **Testing**: Write tests for custom tools and agents
8. **Documentation**: Document tool and agent behavior

## Common Patterns

### Tool Composition
```typescript
// Compose multiple tools
const tools = [
  createTool({
    name: "validate_input",
    description: "Validate user input",
    parameters: [{ name: "input", type: "string", required: true }],
    handler: ({ input }) => validateInput(input)
  }),
  createTool({
    name: "process_data",
    description: "Process validated data",
    parameters: [{ name: "data", type: "string", required: true }],
    handler: ({ data }) => processData(data)
  })
];
```

### Agent Orchestration
```typescript
// Orchestrate multiple agents
const workflow = createMultiAgent({
  name: "content_workflow",
  agents: [
    {
      name: "researcher",
      role: "Research specialist",
      goal: "Find relevant information",
      tools: ["search", "read"]
    },
    {
      name: "writer",
      role: "Content writer",
      goal: "Create compelling content",
      tools: ["write", "edit"]
    },
    {
      name: "reviewer",
      role: "Content reviewer",
      goal: "Review and improve content",
      tools: ["review", "suggest"]
    }
  ],
  tasks: [
    { description: "Research topic", agent: "researcher" },
    { description: "Write content", agent: "writer" },
    { description: "Review content", agent: "reviewer" }
  ]
});
```

### Memory Patterns
```typescript
// Use different memory types for different use cases
const conversationMemory = createConversationMemory({
  maxTokens: 2000,
  returnMessages: true
});

const summaryMemory = createSummaryMemory({
  maxTokens: 1000,
  summaryPrompt: "Summarize the key points"
});

const bufferMemory = createBufferMemory({
  maxTokens: 500,
  returnMessages: true
});
```
