---
description: When editing or working with the react-core package
globs: 
alwaysApply: false
---
# @copilotkit/react-core Package Guide

## Overview

The `@copilotkit/react-core` package is the foundation of CopilotKit, providing the essential React hooks, context providers, and utilities for building AI-powered applications. It's designed to be framework-agnostic and provides headless UI capabilities.

## Core Exports

### Context Providers
- `CopilotKit` - Main provider component that wraps your application
- `CopilotContext` - React context for copilot state management
- `CopilotMessagesContext` - Context for message state management

### Core Hooks

#### useCopilotChat
The primary hook for chat functionality with full control over the UI.

```tsx
import { useCopilotChat } from "@copilotkit/react-core";

const {
  visibleMessages,      // Array of messages currently visible
  appendMessage,        // Function to add new messages
  setMessages,          // Function to set all messages
  deleteMessage,        // Function to remove a message
  reloadMessages,       // Function to reload messages from API
  stopGeneration,       // Function to stop ongoing generation
  reset,               // Function to reset chat state
  isLoading,           // Boolean indicating loading state
  runChatCompletion    // Function to trigger chat completion
} = useCopilotChat({
  id?: string,                    // Unique chat identifier
  headers?: Record<string, string>, // HTTP headers for API requests
  initialMessages?: Message[],    // Initial messages to load
  makeSystemMessage?: SystemMessageFunction // Custom system message generator
});
```

**Key Features:**
- **Headless Design**: Complete control over UI rendering
- **Message Management**: Full CRUD operations on messages
- **Streaming Support**: Real-time message streaming
- **State Persistence**: Maintains chat state across sessions
- **Custom System Messages**: Dynamic system message generation

#### useCopilotAction
Defines actions that the AI can execute within your application.

```tsx
import { useCopilotAction } from "@copilotkit/react-core";

useCopilotAction({
  name: "actionName",           // Unique action identifier
  description: "Action description for AI", // What the action does
  parameters: [                 // Action parameters
    {
      name: "param1",
      type: "string",           // Parameter type
      required: true,           // Whether parameter is required
      description: "Parameter description"
    }
  ],
  handler: async ({ param1 }) => {
    // Action implementation
    return "Success result";
  },
  render: ({ args, status }) => {
    // Optional UI rendering for the action
    return <div>Action UI: {args.param1}</div>;
  },
  renderAndWaitForResponse: ({ args, respond }) => {
    // Interactive UI that waits for user response
    return (
      <ConfirmationDialog
        onConfirm={() => respond({ approved: true })}
        onCancel={() => respond({ approved: false })}
      />
    );
  }
}, dependencies); // Optional dependency array
```

**Action Types:**
- **Simple Actions**: Execute and return results
- **Generative UI**: Render dynamic UI components
- **Interactive Actions**: Require user confirmation/input
- **Catch-All Actions**: Handle undefined actions with `name: "*"`

#### useCopilotReadable
Provides application context to the AI for better understanding.

```tsx
import { useCopilotReadable } from "@copilotkit/react-core";

const contextId = useCopilotReadable({
  description: "Context description",  // What this context represents
  value: yourData,                     // The actual data
  parentId?: string,                   // Parent context for hierarchy
  categories?: string[],               // Context categories for filtering
  available?: "enabled" | "disabled",  // Context availability
  convert?: (desc, val) => string      // Custom serialization function
}, dependencies);
```

**Context Features:**
- **Hierarchical Structure**: Parent-child relationships
- **Category Filtering**: Control context visibility
- **Dynamic Updates**: Real-time context changes
- **Custom Serialization**: Flexible data formatting

#### useCopilotAuthenticatedAction
Creates actions that require user authentication.

```tsx
import { useCopilotAuthenticatedAction_c } from "@copilotkit/react-core";

useCopilotAuthenticatedAction_c({
  name: "protectedAction",
  parameters: [{ name: "data", type: "string" }],
  handler: async ({ data }) => {
    // Only executes if user is authenticated
  }
});
```

### Agent Framework (CoAgents)

#### useCoAgent
Manages agent state and lifecycle.

```tsx
import { useCoAgent } from "@copilotkit/react-core";

const { agentState, setAgentState } = useCoAgent({
  name: "agent_name",           // Agent identifier
  initialState: { data: "init" } // Initial agent state
});
```

#### useCoAgentStateRender
Renders agent state with custom UI components.

```tsx
import { useCoAgentStateRender } from "@copilotkit/react-core";

useCoAgentStateRender({
  name: "agent_name",
  nodeName?: "specific_node",   // Optional specific node
  render: ({ state, nodeName }) => {
    return <CustomComponent {...state} />;
  }
});
```

### LangGraph Integration

#### useLangGraphInterrupt
Handles LangGraph interrupt events for human-in-the-loop workflows.

```tsx
import { useLangGraphInterrupt } from "@copilotkit/react-core";

useLangGraphInterrupt({
  name: "interrupt_name",
  render: ({ event, respond }) => {
    return (
      <InterruptDialog
        event={event}
        onResponse={(response) => respond(response)}
      />
    );
  }
});
```

### Utility Hooks

#### useCopilotAdditionalInstructions
Adds dynamic instructions to the AI.

```tsx
import { useCopilotAdditionalInstructions } from "@copilotkit/react-core";

useCopilotAdditionalInstructions(
  "Additional context or instructions for the AI"
);
```

#### useCopilotRuntimeClient
Manages the runtime client connection.

```tsx
import { useCopilotRuntimeClient } from "@copilotkit/react-core";

const runtimeClient = useCopilotRuntimeClient({
  url: "runtime-url",
  publicApiKey: "api-key",
  headers: {},
  credentials: "include"
});
```

### Context Management

#### useTree
Manages hierarchical context trees.

```tsx
import { useTree } from "@copilotkit/react-core";

const { addElement, removeElement, printTree, getAllElements } = useTree();
```

#### useFlatCategoryStore
Manages flat category-based context storage.

```tsx
import { useFlatCategoryStore } from "@copilotkit/react-core";

const { addElement, removeElement, allElements } = useFlatCategoryStore();
```

## Advanced Patterns

### Custom System Message Generation
```tsx
const makeSystemMessage: SystemMessageFunction = (contextString, instructions) => {
  return `You are a helpful assistant. Context: ${contextString}. Instructions: ${instructions}`;
};

const { appendMessage } = useCopilotChat({ makeSystemMessage });
```

### Action with Complex Parameters
```tsx
useCopilotAction({
  name: "complexAction",
  parameters: [
    { name: "simple", type: "string" },
    { 
      name: "complex", 
      type: "object",
      attributes: [
        { name: "nested", type: "boolean" },
        { name: "array", type: "string[]" }
      ]
    }
  ],
  handler: async ({ simple, complex }) => {
    // Handle complex parameter structure
  }
});
```

### Context with Categories
```tsx
useCopilotReadable({
  description: "User preferences",
  value: userPrefs,
  categories: ["user", "preferences"]
});

// Only available in specific contexts
useCopilotReadable({
  description: "Form data",
  value: formData,
  categories: ["form", "current"]
});
```

### Error Handling
```tsx
useCopilotAction({
  name: "riskyAction",
  handler: async ({ param }) => {
    try {
      const result = await riskyOperation(param);
      return { success: true, data: result };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
});
```

## Best Practices

1. **Dependency Management**: Always provide dependencies array for hooks that capture values
2. **Context Organization**: Use categories and hierarchy for better context management
3. **Action Design**: Create focused, well-described actions with proper error handling
4. **Performance**: Use `useCallback` and `useMemo` for expensive operations
5. **Type Safety**: Leverage TypeScript for parameter and return type safety
6. **Error Boundaries**: Wrap CopilotKit components in error boundaries

## Integration Points

- **Runtime Communication**: GraphQL-based communication with backend
- **Authentication**: Built-in auth support for cloud deployments
- **Streaming**: Real-time response streaming
- **State Management**: Persistent conversation and agent state
- **Custom UI**: Complete control over rendering and styling
